# ----------------------------------------------------------------------
# !!! IMPORTANT REQUIREMENT !!!
# This firmware requires ESPHome 2026.2.0 or newer.
# Native support for the ESP32-P4 was introduced in this version.
# Older versions will fail to compile the board definition.
# ----------------------------------------------------------------------

esphome:
  name: froeling
  friendly_name: "Froeling"
  
  on_boot:
    - priority: -10 
      then:
        - component.update: lambdatronic 
        - delay: 2s
        # Initial check on boot
        - binary_sensor.template.publish:
            id: modbus_status
            state: !lambda 'return !std::isnan(id(boiler_temp_actual).state);'

# dallas: DS18B20 on GPIO54 (Right Header)
one_wire:
  - platform: gpio
    pin: 54  # "ignore_pin_validation_error" removed

esp32:
  board: esp32-p4-evboard
  variant: esp32p4 #Since P4 is brand new, it's not on the list. variant: esp32p4 tells ESPHome "Ignore the name, just trust me it's a P4."
  framework:
    type: esp-idf

logger:
  level: INFO
  baud_rate: 0 

ota:
  - platform: esphome
  
web_server:
  port: 80
  version: 3

time:
  - platform: sntp
    id: sntp_time
    timezone: "CET-1CEST,M3.5.0,M10.5.0/3"

# ----------------------------------------------------------------------
# GLOBAL CONSTANTS & VARIABLES
# ----------------------------------------------------------------------
globals:
  # -- Constants (Config) --
  - id: safety_countdown_start_val
    type: int
    initial_value: '1200'  # 20 Minutes
  - id: min_flow_threshold
    type: float
    initial_value: '1.0'   # Minimum temp to consider "On"
  - id: curve_out_low
    type: float
    initial_value: '-10.0' # Curve calc point A
  - id: curve_out_high
    type: float
    initial_value: '10.0'  # Curve calc point B

  # -- Dynamic State --
  - id: heating_countdown_seconds
    type: int
    initial_value: '0'
  - id: internal_schedule_target
    type: float
    initial_value: '0.0'

# ----------------------------------------------------------------------
# 1. CONNECTIVITY (ESP32-P4 IP101 HARDWARE)
# ----------------------------------------------------------------------
ethernet:
  type: IP101
  phy_addr: 1
  # Validation errors removed; P4 knows these pins exist
  mdc_pin: 31
  mdio_pin: 52
  clk:
    pin: 50
    mode: CLK_EXT_IN
  power_pin: 51

uart:
  id: froeling_uart
  tx_pin: GPIO32
  rx_pin: GPIO4
  baud_rate: 57600
  stop_bits: 1
  data_bits: 8
  parity: NONE

modbus:
  id: modbus_hub
  uart_id: froeling_uart
  send_wait_time: 250ms 

modbus_controller:
  - id: lambdatronic
    address: 2
    modbus_id: modbus_hub
    setup_priority: -10
    command_throttle: 50ms 
    update_interval: 30s

# ----------------------------------------------------------------------
# 2. WATCHDOG & FAIL-SAFE LOGIC
# ----------------------------------------------------------------------
api:
  reboot_timeout: 0s
  on_client_disconnected:
    - logger.log: "API Disconnected! Forcing Fail-Safe."
    - lambda: |-
        if (id(boiler_being_poked).state) {
          id(heating_countdown_seconds) = id(safety_countdown_start_val);
          id(esp_status).update(); 
          ESP_LOGW("custom", "API Connection lost while heating. Entering Countdown mode.");
        }

# ----------------------------------------------------------------------
# 3. SCRIPTS
# ----------------------------------------------------------------------
script:
  - id: ha_offline_shutdown_sequence
    mode: restart
    then:
      - logger.log: "Logic Lost. ESP Reverting to Master Schedule."

  - id: calculate_internal_schedule
    mode: restart
    then:
      - lambda: |-
          auto now = id(sntp_time).now();
          float calculated_target = 0.0;
          
          if (now.is_valid()) {
            int day = now.day_of_week;
            std::string sch_str = "";
            
            if      (day == 2) sch_str = id(sch_1).state; // Mon
            else if (day == 3) sch_str = id(sch_2).state; // Tue
            else if (day == 4) sch_str = id(sch_3).state; // Wed
            else if (day == 5) sch_str = id(sch_4).state; // Thu
            else if (day == 6) sch_str = id(sch_5).state; // Fri
            else if (day == 7) sch_str = id(sch_6).state; // Sat
            else if (day == 1) sch_str = id(sch_7).state; // Sun

            size_t comment_pos = sch_str.find('#');
            if (comment_pos != std::string::npos) sch_str = sch_str.substr(0, comment_pos);
            sch_str.erase(std::remove_if(sch_str.begin(), sch_str.end(), ::isspace), sch_str.end());

            bool schedule_active = false;
            float base_offset = 0.0;

            if (!sch_str.empty()) {
              int current_min = now.hour * 60 + now.minute;
              size_t pos = 0;
              while (pos < sch_str.length()) {
                size_t semi = sch_str.find(';', pos);
                std::string segment = sch_str.substr(pos, semi == std::string::npos ? std::string::npos : semi - pos);
                size_t dash = segment.find('-');
                size_t at = segment.find('@');
                
                if (dash != std::string::npos) {
                  std::string start_s = segment.substr(0, dash);
                  std::string end_s = segment.substr(dash + 1, (at == std::string::npos ? std::string::npos : at - dash - 1));
                  auto parse_time = [](std::string s) {
                    size_t c = s.find(':');
                    if (c == std::string::npos) return atoi(s.c_str()) * 60;
                    return atoi(s.substr(0, c).c_str()) * 60 + atoi(s.substr(c+1).c_str());
                  };
                  if (current_min >= parse_time(start_s) && current_min < parse_time(end_s)) {
                    schedule_active = true;
                    if (at != std::string::npos) base_offset = atof(segment.substr(at + 1).c_str());
                    break;
                  }
                }
                if (semi == std::string::npos) break;
                pos = semi + 1;
              }
            }

            if (schedule_active) {
              float outside;
              if (!std::isnan(id(dallas_outside_temp).state)) {
                outside = id(dallas_outside_temp).state;
              } 
              else if (!std::isnan(id(outside_temp_sensor).state)) {
                outside = id(outside_temp_sensor).state;
              } 
              else {
                outside = 0.0f;
              }
                          
              float y1 = id(curve_minus_10).state;
              float y2 = id(curve_plus_10).state;
              float x1 = id(curve_out_low);
              float x2 = id(curve_out_high);
              
              calculated_target = y1 + ((outside - x1) * (y2 - y1) / (x2 - x1)) + base_offset;
            }
          }
          id(internal_schedule_target) = calculated_target;

  - id: write_modbus_target
    mode: restart
    parameters:
      target_val: float
    then:
      - lambda: |-
          if (target_val > id(min_flow_threshold)) {
            id(hk02_flow_setpoint_external).make_call().set_value(target_val * 2.0).perform();
            id(esp_hk2_flow_target_temp).publish_state(target_val);
          } else {
            id(esp_hk2_flow_target_temp).publish_state(id(hk02_flow_setpoint_external).state / 2.0);
          }

# ----------------------------------------------------------------------
# 4. PRIMARY CONTROLS
# ----------------------------------------------------------------------
text:
  - platform: template
    name: "Time (Manual Override)"
    id: manual_time_input
    mode: text
    optimistic: true
    restore_value: false 
    on_value:
      then:
        - lambda: |-
            if (id(sntp_time).now().is_valid()) return;
            int yr, mon, day, hr, min;
            if (sscanf(x.c_str(), "%d-%d-%d %d:%d", &yr, &mon, &day, &hr, &min) == 5) {
              struct tm t = {0};
              t.tm_year = yr - 1900; t.tm_mon = mon - 1; t.tm_mday = day;
              t.tm_hour = hr; t.tm_min = min; t.tm_isdst = -1;
              time_t epoch = mktime(&t);
              if (epoch != (time_t)-1) {
                struct timeval tv = { .tv_sec = epoch, .tv_usec = 0 };
                settimeofday(&tv, NULL);
                ESP_LOGI("custom", "Clock manually synced to: %s", x.c_str());
              }
            }

  - platform: template
    name: "1: Mo"
    id: sch_1
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "2: Tu"
    id: sch_2
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "3: We"
    id: sch_3
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "4: Th"
    id: sch_4
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "5: Fr"
    id: sch_5
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "6: Sa"
    id: sch_6
    mode: text
    optimistic: true
    restore_value: true
  - platform: template
    name: "7: Su"
    id: sch_7
    mode: text
    optimistic: true
    restore_value: true

number:
  - platform: template
    name: "HK2 Flow Target Temp"
    id: heating_setpoint_holding
    unit_of_measurement: "°C"
    min_value: 0
    max_value: 50
    step: 1
    optimistic: false
    initial_value: 0
    restore_value: true 
    internal: true
    set_action:
      - lambda: |-
          if (id(esp_api_status).state && id(ad_heartbeat_status).state) {
            id(heating_setpoint_holding).publish_state(id(ha_target_flow_helper).state);
          } else {
            id(heating_setpoint_holding).publish_state(x);
          }

  - platform: template
    name: "HK2 Flow Temp -10 (Master)"
    id: curve_minus_10
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 50
    step: 1
    initial_value: 42
    optimistic: true
    restore_value: true

  - platform: template
    name: "HK2 Flow Temp +10 (Master)"
    id: curve_plus_10
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 50
    step: 1
    initial_value: 34
    optimistic: true
    restore_value: true

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    id: hk02_flow_setpoint_external
    address: 8001
    internal: true 
    register_type: holding
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    id: froeling_hk2_operating_mode_raw
    address: 8047
    register_type: holding
    value_type: U_WORD
    internal: true

# ----------------------------------------------------------------------
# 5. DECISION ENGINE
# ----------------------------------------------------------------------
interval:
  - interval: 60s
    then:
      - script.execute: calculate_internal_schedule

  - interval: 59s
    then:
      - lambda: |-
          static bool startup_lock_released = false; 
          float final_target = 0.0;

          if (id(esp_api_status).state && id(ad_heartbeat_status).state) {
            id(heating_countdown_seconds) = 0; 
            float ha_val = id(ha_target_flow_helper).state;
            
            if (!startup_lock_released) {
              if (!std::isnan(ha_val) && ha_val > 0.1f) startup_lock_released = true;
              else return; 
            }

            if (id(boiler_being_poked).state) {
              final_target = ha_val;
            }
          } 
          else if (id(heating_countdown_seconds) > 0) {
            final_target = id(heating_setpoint_holding).state; 
          }
          else {
            final_target = id(internal_schedule_target);
          }

          id(write_modbus_target).execute(final_target);

  - interval: 1s
    then:
      - lambda: |-
          if (id(heating_countdown_seconds) > 0) id(heating_countdown_seconds)--;
          id(esp_status).update(); 

  - interval: 60s
    then:
      - lambda: |-
          auto now = id(sntp_time).now();
          if (now.is_valid()) id(manual_time_input).publish_state(now.strftime("%Y-%m-%d %H:%M"));
          else if (id(manual_time_input).state.find(':') == std::string::npos) id(manual_time_input).publish_state("YYYY-MM-DD HH:MM");

  - interval: 30s
    then:
      - binary_sensor.template.publish:
          id: modbus_status
          state: !lambda 'return !std::isnan(id(boiler_temp_actual).state);'

# ----------------------------------------------------------------------
# 6. SENSORS
# ----------------------------------------------------------------------
sensor:
  - platform: homeassistant
    id: ha_target_flow_helper
    entity_id: input_number.hk2_target_flow_temp
    internal: true
    on_value:
      then:
        - lambda: 'if (id(ad_heartbeat_status).state) id(heating_setpoint_holding).publish_state(x);'

  - platform: template
    name: "HK2 Flow Target Temp (ESP)"
    id: esp_hk2_flow_target_temp
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: "mdi:math-compass"
    entity_category: ""

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Ash Emptying"
    register_type: read
    address: 86
    unit_of_measurement: "h"
    value_type: U_WORD
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Log Wood Mode"
    address: 76
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "h"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Secondary Air"
    address: 12
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Since Maintenance"
    address: 55
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "h"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Pump Running"
    address: 2602
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "h"
    entity_category: diagnostic
    icon: "mdi:timer-outline"

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Temp"
    id: boiler_temp_actual
    address: 0
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Flue Gas Temp"
    address: 1
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Return Sensor"
    address: 9
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Residual Oxygen"
    address: 3
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Oxygen Controller"
    address: 16
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Primary Air"
    address: 11
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Induced Draught Speed"
    address: 6
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "rpm"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Induced Draught Control"
    address: 13
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Operating Hours"
    address: 20
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "h"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Fire Maintenance"
    address: 24
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "h"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Outside Temp"
    id: outside_temp_sensor
    address: 1000
    register_type: read
    value_type: S_WORD 
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Pump Control"
    id: boiler_1_pump_ctrl
    address: 1632
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Temp Sensor 1"
    address: 2000
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Temp Sensor 2"
    address: 2004
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Temp Sensor 3"
    address: 2005
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Temp Sensor 4"
    address: 2002
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Charge State"
    address: 2006
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Pump Control"
    id: buffer_1_pump_ctrl
    address: 2003
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "HK2 Flow Actual Temp"
    id: hk02_flow_temperature_actual
    address: 1060
    register_type: read
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "HK2 Flow Target Temp"
    id: hk02_flow_temperature_target
    address: 1061
    register_type: read
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Temp"
    id: collector_temp_sensor
    address: 2601
    register_type: read
    value_type: S_WORD 
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Return Temp"
    id: coll_ret_temp_master
    address: 2611
    register_type: read
    value_type: S_WORD 
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Flow Temp"
    address: 2612
    register_type: read
    value_type: S_WORD 
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.5
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Pump Control"
    address: 2600
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Boiler Pump Control"
    id: coll_pump_ctrl_master
    address: 2622
    register_type: read
    value_type: U_WORD
    unit_of_measurement: "%"
    entity_category: diagnostic
  
  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    id: boiler_state_raw
    address: 4001
    register_type: read
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    id: boiler_system_state_raw
    address: 4000
    register_type: read
    value_type: U_WORD
    internal: true

  - platform: dallas_temp
    name: "Outside Temp"
    id: dallas_outside_temp
    address: 0xa6000000b3211a28 
    update_interval: 60s

  - platform: dallas_temp
    name: "Room Temp"
    address: 0xe3000000b318b828 
    update_interval: 60s

# ----------------------------------------------------------------------
# 7. BINARY SENSORS
# ----------------------------------------------------------------------
binary_sensor:
  - platform: template
    name: "AppDaemon Status" 
    lambda: 'return id(esp_api_status).state && id(ad_heartbeat_status).state;'
    device_class: connectivity
    entity_category: ""

  - platform: status
    name: "ESP HA API Status"
    id: esp_api_status
    entity_category: ""

  - platform: template
    name: "ESP Modbus Status"
    id: modbus_status
    device_class: connectivity
    entity_category: ""

  - platform: homeassistant
    name: "AppDaemon Connection Status"
    id: ad_heartbeat_status
    entity_id: input_boolean.appdaemon_running 
    device_class: connectivity
    on_release:
      then:
        - if:
            condition: {binary_sensor.is_on: boiler_being_poked}
            then: 
              - lambda: |-
                  id(heating_countdown_seconds) = id(safety_countdown_start_val);
                  id(esp_status).update();
                  ESP_LOGW("custom", "AppDaemon Boolean turned OFF while heating. 20m safety run.");
        - lambda: |-
            float current_actual = id(hk02_flow_setpoint_external).state;
            if(!std::isnan(current_actual) && current_actual > 0) id(heating_setpoint_holding).publish_state(current_actual);

  - platform: template
    name: "Heating On"
    id: boiler_being_poked
    lambda: |-
      if (id(esp_api_status).state && id(ad_heartbeat_status).state) {
        return (id(ha_target_flow_helper).state >= id(min_flow_threshold));
      }
      return (id(heating_countdown_seconds) > 0) || (id(esp_hk2_flow_target_temp).state > id(min_flow_threshold));

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "HK2 Pump Status"
    id: hk2_pump_on_off
    address: 1060
    register_type: coil
    entity_category: diagnostic
    device_class: running

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Boiler Pump Status"
    id: boiler_1_pump_status
    address: 1632
    register_type: read
    lambda: "return x > 0;" 
    entity_category: diagnostic
    device_class: running

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Buffer Pump Status"
    id: buffer_1_pump_status
    address: 2003
    register_type: read
    lambda: "return x > 0;" 
    entity_category: diagnostic
    device_class: running

  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "Collector Pump Status"
    id: solar_pump_status
    address: 2600
    register_type: read
    lambda: "return x > 0;" 
    entity_category: diagnostic
    device_class: running

  - platform: template
    name: "Collector Boiler Pump Status"
    lambda: 'return id(coll_pump_ctrl_master).state > 0;'
    entity_category: diagnostic
    device_class: running

# ----------------------------------------------------------------------
# 8. TEXT SENSORS
# ----------------------------------------------------------------------
text_sensor:
  - platform: template
    name: "ESP Status"
    id: esp_status
    icon: "mdi:robot"
    update_interval: never
    lambda: |-
      if (id(esp_api_status).state && id(ad_heartbeat_status).state) return {"Slave"};
      if (id(heating_countdown_seconds) > 0) {
        int m = id(heating_countdown_seconds) / 60;
        int s = id(heating_countdown_seconds) % 60;
        char buf[32];
        sprintf(buf, "Heating Countdown: %02d:%02d", m, s);
        return {buf};
      }
      return {"Master"};

  - platform: template
    name: "Boiler State"
    id: boiler_state_text
    icon: "mdi:pipe-valve"
    entity_category: diagnostic
    lambda: |-
      int value = (int)id(boiler_state_raw).state;
      switch (value) {
        case 0: return std::string("MALFUNCTION");
        case 1: return std::string("Boiler off");
        case 2: return std::string("Heating up");
        case 3: return std::string("Heating");
        case 4: return std::string("Fire maintenance");
        case 5: return std::string("Fire off");
        case 6: return std::string("Door open");
        case 7: return std::string("Preparation");
        case 8: return std::string("Preheating");
        case 9: return std::string("Igniting");
        case 10: return std::string("Stopping wait");
        case 11: return std::string("Stopping wait 1");
        case 12: return std::string("Stopping feed 1");
        case 13: return std::string("Stopping wait 2");
        case 14: return std::string("Stopping feed 2");
        case 15: return std::string("Cleaning");
        case 16: return std::string("Wait 2h");
        case 17: return std::string("Suction / Heating");
        case 18: return std::string("Misfire");
        case 19: return std::string("Ready for operation");
        case 20: return std::string("Close grate");
        case 21: return std::string("Empty stoker");
        case 22: return std::string("Preheat");
        case 23: return std::string("Suction");
        case 24: return std::string("Close RSE");
        case 25: return std::string("Open RSE");
        case 26: return std::string("Tip grate");
        case 27: return std::string("Preheat-ignite");
        case 28: return std::string("Remaining feed");
        case 29: return std::string("Refill stoker");
        case 30: return std::string("Heat up lambda probe");
        case 31: return std::string("Gebläsenachlauf I");
        case 32: return std::string("Gebläsenachlauf II");
        case 33: return std::string("Abgestellt");
        case 34: return std::string("Nachzünden");
        case 35: return std::string("Zünden Warten");
        case 36: return std::string("FB: Close RSE");
        case 37: return std::string("FB: Kessel belüften");
        case 38: return std::string("FB: Zünden");
        case 39: return std::string("FB: min. Einschub");
        case 40: return std::string("Close RSE");
        case 41: return std::string("MALFUNCTION: STB/NA");
        case 42: return std::string("MALFUNCTION: Kipprost");
        case 43: return std::string("MALFUNCTION: FR-Überdr.");
        case 44: return std::string("MALFUNCTION: Türkont.");
        case 45: return std::string("MALFUNCTION: Saugzug");
        case 46: return std::string("MALFUNCTION: Umfeld");
        case 47: return std::string("FEHLER: STB/NA");
        case 48: return std::string("FEHLER: Kipprost");
        case 49: return std::string("FEHLER: FR-Überdr.");
        case 50: return std::string("FEHLER: Türkont.");
        case 51: return std::string("FEHLER: Saugzug");
        case 52: return std::string("FEHLER: Umfeld");
        case 53: return std::string("FEHLER: Stoker");
        case 54: return std::string("MALFUNCTION: Stoker");
        case 55: return std::string("FB: Stoker leeren.");
        case 56: return std::string("Vorbelüften");
        case 57: return std::string("MALFUNCTION: Hackgut");
        case 58: return std::string("FEHLER: Hackgut");
        case 59: return std::string("NB: Tür offen");
        case 60: return std::string("NB: Anheizen");
        case 61: return std::string("NB: Heizen");
        case 62: return std::string("ERROR: STB/NA");
        case 63: return std::string("ERROR: General");
        case 64: return std::string("NB: Feuer Aus");
        case 65: return std::string("Self-test active");
        case 66: return std::string("Troubleshooting 20min");
        case 67: return std::string("ERROR: Drop shaft");
        case 68: return std::string("MALFUNCTION: Drop shaft");
        case 69: return std::string("Cleaning possible");
        case 70: return std::string("Heating - Cleaning");
        case 71: return std::string("SH Heating up");
        case 72: return std::string("SH Heating");
        case 73: return std::string("SH Heat/Stop");
        case 74: return std::string("MALFUNCTION certain");
        case 75: return std::string("AGR post-run");
        case 76: return std::string("AGR cleaning");
        case 77: return std::string("Ignition OFF");
        case 78: return std::string("Clean filter");
        case 79: return std::string("Heating assistant");
        case 80: return std::string("SH Ignite");
        case 81: return std::string("SH Malfunction");
        case 82: return std::string("Sensor check");
        default: return "Unknown (" + to_string(value) + ")";
      }

  - platform: template
    name: "Boiler System State"
    id: system_state_text
    icon: "mdi:cog"
    entity_category: diagnostic
    lambda: |-
      int value = (int)id(boiler_system_state_raw).state;
      switch (value) {
        case 1: return std::string("Automatic");
        case 2: return std::string("Summer mode");
        case 3: return std::string("Frost protection");
        case 4: return std::string("Service mode");
        case 5: return std::string("Switched Off");
        default: return "Unknown (" + to_string(value) + ")";
      }

# ----------------------------------------------------------------------
# 8. SELECTS
# ----------------------------------------------------------------------
select:
  - platform: modbus_controller
    modbus_controller_id: lambdatronic
    name: "HK2 Enabled"
    id: hk2_clearance_template
    address: 8029
    value_type: U_WORD
    optionsmap: {"Off": 0, "On": 1}
    optimistic: false
